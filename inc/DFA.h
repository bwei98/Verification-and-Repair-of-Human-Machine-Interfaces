/** @file DFA.h
 *  @brief Header for DFA structure
 *  @author Brian Wei
 *
 *  We implement the structure for a DFA with the transition matrix stored as an
 *  array which maps origin state and symbol (as indexes) to the destination state.
 *  This allowed efficient access into the array, which is a highly used operation
 *  within the algorithms that are implemented here.
 *  The DFA_find_pattern function is a brute force algorithm that iterates over
 *  all permutations of states in the DFA to see if there are any suitable in being
 *  a match to the pattern state machine.
 */

#ifndef __VERIF_DFA_H__
#define __VERIF_DFA_H__

#include <stdbool.h>
#include <stdio.h>

#define DFA_INVALID_SYMBOL      (-1)
#define DFA_INVALID_ARG         (-2)
#define DFA_MEMORY_ERROR        (-3)
#define DFA_PATTERN_NOT_FOUND   (-4)
#define DFA_NOT_YET_IMPL        (-5)

/* Structure for a DFA; transition matrix is structured as:
 *                  symbol
 * Starting state   42   99
 *             0    0    -1
 *             1    1    0
 *  where the destination is in the cells of the array, -1 indicates that
 *  the transition does noe exist.  Symbols 42 and 99 are specified in the
 *  alphabet symbols array which must be in this case {42, 99}
 *  */
typedef struct dfa {
  int num_states;           /* Number of states */
  int initial_state;        /* Initial state    */
  bool *final_states;       /* Accepting states */
  int alphabet_size;        /* Size of alphabet */
  int *alphabet_symbols;    /* Symbols in the alphabet  */
  int *transition_matrix;   /* Transition matrix of num_states * alphabet_size
                             * where tm[i][j] is the destination from state i
                             * on transition alphabet_symbols[j] */
} dfa_t;

/* Output for when a pattern is identified within a DFA */
typedef struct pattern_output {
    int *states;            /* States in the DFA  */
    int *symbols;           /* Symbols of the DFA */
} pattern_output_t;


/** @brief Constructs a new DFA
 *
 * @param dfa Pointer to fill the data
 * @param num_states Number of states in the DFA
 * @param alphabet_size Size of the alphabet
 * @param finals List of final states
 * @param transition_matrix Transition matrix
 * @return zero on success, negative error code on failure
 */
int DFA_new(dfa_t *dfa, int num_states, int alphabet_size, int initial_state,
            const bool *finals, const int *symbols,
            const int *transition_matrix);


/** @brief Returns the index of a given symbol based on the DFA's alphabet
 *
 * @param dfa DFA that we want to observe
 * @param symbol Symbol to look for
 * @return Index in the alphabet_symbols array of the symbol or a negative error code if not found
 */
int get_symbol_index(dfa_t *dfa, int symbol);

/** @brief Runs a trace through a DFA
 *
 * @param dfa DFA to run
 * @param trace Input trace, integer array of symbols
 * @param length Length of input trace
 * @return 1 if accept, 0 if reject, negative error code if other failure
 */
int DFA_run_trace(dfa_t *dfa, const int *trace, int length);

/** @brief Finds a pattern DFA withing a given DFA
 *
 * A brute force approach which considers all permutations of states in the DFA and checks
 * that there is some set of symbols for which the transitions will match in the two state
 * machines.
 *
 * @note Returned pointer is generated by a malloc call and thus should be freed after use
 *
 * @param main_dfa Main DFA in which we want to find a pattern
 * @param pattern DFA representing the pattern we want
 * @return an array indicating the states and symbols which match the pattern, or NULL is it cannot be found
 */
pattern_output_t *DFA_find_pattern(dfa_t *main_dfa, dfa_t *pattern);

/** @brief Finds a pattern in a DFA and modifies it to a target pattern
 *
 * @note Does not currently support when original_pattern and target_pattern have a different
 *          number of states
 * @todo Document this
 *
 * @param main_dfa
 * @param original_pattern
 * @param target_pattern
 * @return 0 on success, negative error code on failure
 */
int DFA_modify(dfa_t *main_dfa, dfa_t *original_pattern, dfa_t *target_pattern);

/** @brief Prints information representing the construction of the DFA to specified file
 *
 * @param dfa DFA whose data to print
 * @param f File pointer for output
 */
void DFA_print(dfa_t *dfa, FILE *f);


/** @brief Frees memory associated with a pattern_output_t
 *
 * @param pattern Pattern to free
 */
void DFA_free_pattern(pattern_output_t *pattern);

#endif /* __VERIF_DFA_H__ */
